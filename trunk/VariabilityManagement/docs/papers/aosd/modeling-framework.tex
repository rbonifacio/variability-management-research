% ================================= Modeling Framework
% =================================

\section{Modeling Framework}\label{sec:modeling-framework}

In this Section we describe the notation proposed to represent variability
management as crosscutting mechanisms. In fact, our notation is a slight
customization of the \emph{Crosscutting Modeling Framework}, proposed by Masuhara
and Kiczales (the MK framework)~\cite{Masuhara:2003aa}. The goal of the MK
framework is to explain how different \emph{aspect-oriented} mechanisms support
crosscutting modularity. In order to do that, each mechanism is represented as a
three-part description: the related weaving processes take two programs as input,
which crosscut each other with respect to the resulting program or
computation~\cite{Masuhara:2003aa}.
Their requirement for characterizing a mechanism as crosscutting is fulfilled by
our approach, in the sense that different specifications contribute to the
definition of a specific SPL member, as illustrated in the previous section. 

%As a
%consequence, due to its crosscutting nature, the modeling framework proposed
%in~\cite{Masuhara:2003aa} is suitable for formalizing variability management
%compositions.

Similarly to the MK work, our modeling framework represents each
weaver as an 6-tuple (Eq.~\ref{eq:tuple} and Table~\ref{tab:tup-01}),
highlighting the contribution of each input language in the composition
processes. We represent each weaver by filling in the six parameters of our
6-tuple representation, by providing a reference implementation for each weaver,
and by stating how elements of the weaver implementation correspond to elements
of the model.


% NOTA: Esse texto foi levado para  a secao anterior.
%In our modeling framework, the concrete semantics of those weavers (and the
%meta-model of the input and output languages) are described using the Haskell
%programming language. This led to concise descriptions and
%kept our model close to the MK work, where their weaving processes are specified
%in the Scheme programming language. The choice for Haskell was motivated by
%several factors, such as improved readability and our background in the language.
%The resulting source code is available at a web site~\cite{SPG:site}.

\begin{equation}
W = \{o, o_{jp}, L, L_{id}, L_{eff}, L_{mod}\},
\label{eq:tuple}
\end{equation}

\begin{table}[h]
\begin{center}
\caption{Modeling framework elements.} \label{tab:tup-01}
\begin{tabular}{||p{0.6in}||p{2.4in}||}
  \hline
  {\bf Element} & {\bf Description} \\
   \hline
  $o$              & Output language used for describing the results of the weaving process \\ \hline
  $o_{jp}$       & Set of join points in the output language \\ \hline
  $L$              & Set of languages used for describing the input specifications \\ \hline
  $L_{ID}(l)$      & Set of constructions in each input language $l$, used for identifying the output join points \\ \hline
  $L_{EFF}(l)$   & For each input language $l$, this element represent the effect of its constructions in the weaving process \\ \hline
  $L_{MOD}(l)$  & Set of modular unities of each input language $l$\\
  \hline
\end{tabular}
\end{center}
\end{table}

In the next sections we describe the semantics of
our weaving process, modeling one weaver for each source of variability and
providing reference implementations for them.

\subsection{Variability in function}\label{sub:pd-weaver}

Variability in function occurs when a particular function might exist in some
products and not in others~\cite{Bachmann:2001aa}. For this source of
variability, a corresponding weaver is responsible for selecting scenarios based
on specific product configurations.
%Although in this paper we focus only in the
%selection of scenarios that should be assembled in specific instances of the SPL,
%this weaver can be easily extended for managing variabilities in other kinds of
%assets (aiming at selecting design elements, source code, and test cases).

This weaver is implemented by the function \emph{selectScenarios}
(next code fragment). It takes as input the list of \emph{scenario
ids} that should be selected for a specific feature expression,  the \emph{SPL
use case model} (spl), and the $product$ being generated. Then, this function
returns a new configuration of the product, which is refined by each scenario $s$
in the SPL use case model that satisfies the condition $(id\ s) \in\ ids$. In
this case, the configuration knowledge (CK) and the SPL use case model
(UCM) crosscut each other with respect to the list of scenarios added to the
specific SPL member.

\begin{code}
 selectScenarios ids spl product =
  addScenarios (product, scenarios)
  where 	
    scenarios = [s | s <- (splScenarios spl), (id s) in ids]
    addScenarios ...
\end{code}

Below we present the concrete instantiation of the first line of the
\emph{eShop} configuration knowledge (Table~\ref{tab:eshop-ck}), which deals with this
source of variability. Notice that the configuration knowledge
binds the first parameter of the \emph{selectScenario} function. Therefore,
particularly to this weaver, the configuration knowledge contributes to
the identification of the scenarios that must be added to a specific product.


\begin{code}
c1 = Configuration (``eShop'',
   selectScenarios[``SC01'', ``SC02''])
\end{code}

The model of the \emph{Variability in Function Weaver}, in terms of the
framework, is shown in Table~\ref{tab:vf-weaver}. The \emph{selectScenarios}
function is used to argue that the model is realizable and
appropriate~\cite{Masuhara:2003aa}.
We achieve this by matching the model elements to
corresponding parameters and auxiliary functions in the implementation.

The input languages
\emph{configuration knowledge} (CK) and \emph{SPL use case model} (UCM) contributes to the
binding of \emph{selectScenarios} parameters. An instance of the SPL use
case model corresponds to the specification of all SPL scenarios.
Instead, the identification of which scenarios must be added to a specific
feature expression are documented in the configuration knowledge. Finally, the
\emph{product configuration} (PC) specifies which features were selected for a
specific product.

\begin{table}[htb]
\begin{center}
\caption{Model of Product Derivation} \label{tab:vf-weaver}
\begin{tabular}{p{0.6in}p{2.4in}}
   \hline\noalign{\smallskip}
  {\bf Element} & {\bf Description} \\
   \noalign{\smallskip}
   \hline
   \noalign{\smallskip}
   $o$              & Product specific scenarios (list of scenarios) \\
   $o_{jp}$        	& Scenario declarations \\
   $L$              & \{UCM, CK, PC\} \\
   $UCM_{ID}$ 		& SPL scenarios \\
   $CK_{ID}$    	& Feature expressions and scenario IDs\\
   $PC_{ID}$    	& Product specific feature selection \\
   $UCM_{EFF}$ 		& Provides declaration of scenarios \\
   $CK_{EFF}$    	& Relates feature expressions to scenario Ids  \\
   $PC_{EFF}$    	& Triggers scenario selection \\
   $UCM_{MOD}$ 		& Scenario \\
   $CK_{MOD}$    	& Each configuration item  \\
   $PC_{MOD}$    	& Each selected feature \\
  \hline
  \end{tabular}
\end{center}
\end{table}

% The UCM has a greater importance over the other input languages ($UCM_{EFF}$),
% since it declares the parts that compose the product specific scenarios (the
% output of this weaver process generated by the \emph{selectScenarios} function).

\subsection{Variability in data}\label{sub:bind-weaver}

This kind of variability occurs whenever two or more scenarios share the same
behavior (the sequence of steps) and differ in relation only to values of a same
concept. For instance, the \emph{Proceed to Purchase} scenario
(Figure~\ref{fig:proceed-to-checkout}) can be reused for different kinds
of shipping method. Without this parameterized specification, and aiming, for
example, at automatically generating a test case suite with a good coverage, it
would be necessary to create a scenario for each kind of shipping method.


% This weaver takes into consideration \emph{scenario specifications} and
% \emph{product configurations}, which defines the domain values of a parameter.
% Thus, in order to reduce the coupling between scenarios and features, we
% propose a mapping that relate them. A constraint must be obeyed in this
% mapping: features related to parameters must be either an {\bf alternative
% feature} or an {\bf or
% feature}~\cite{gheyi-alloy-06,czarnecki-wsfactory-2005,czarnecki-book}.


The next code fragment presents the reference implementation for solving scenario
parameterization. The function \emph{bindParameter} takes as input the identifier
of a parameter ($pId$); the identifier of a feature ($fId$); the SPL use case model ($spl$); and the
$product$ being generated. Then, it replaces all references to $pId$ in
$product$ by a suitable representation of the corresponding feature selection ($features$), which is represented by the product configuration.
For example, if a product is configured with both \emph{Economical} and \emph{Fast}
shipping methods, applying this weaver for the \emph{Proceed to
Purchase} scenario (Figure~\ref{fig:proceed-to-checkout}) replaces each reference to the ``SM'' parameter by
the text (\emph{Economical, Fast}).

\begin{code}
bindParameter pId fId spl product =
  bindParameter' product steps options
  where
    features = (configuration product)
    steps = [s | s <- (steps spl), (s 'refers' pId)]
    options = selectedOptions (features, fId)
    bindParameter' ...
\end{code}   	

Below we present the concrete instantiation of the fifth line of
the \emph{eShop} configuration knowledge (Table~\ref{tab:eshop-ck}), which deals
with this source of variability. In this case, the configuration knowledge
binds the first two parameters of the \emph{bindParameter} function. Therefore,
particularly to this weaver, the configuration knowledge contributes to
a mapping between \emph{parameter ids}, used in the SPL scenarios, and (alternative
or optional) features in the feature model. Such a mapping reduces the
coupling between SPL use case models and feature models.

\begin{code}
c5 = Configuration (``ShippingMethod'',
   bindParameter(``SM'', ``ShippingMethod''))
\end{code}

Table~\ref{tab:bp-weaver} represents the model of \emph{Variability in Data}. Since this weaver solves parameters in scenario specifications, its output
language is a list of product specific scenarios.


\begin{table}[th]
\begin{center}
\caption{Model of Bind Parameters Weaver} \label{tab:bp-weaver}
\begin{tabular}{p{0.7in}p{2.3in}}
   \hline\noalign{\smallskip}
  {\bf Element} & {\bf Description} \\
   \noalign{\smallskip}
   \hline
   \noalign{\smallskip}
   $o$              	& Scenarios with resolved parameters  \\
   $o_{jp}$      	  	& Each resolved parameter \\
   $L$               	& \{UCM, CK, PC\} \\
   $UCM_{ID}$ 			& Parameterized steps \\
   $CK_{ID}$ 			& Mapping of parameters to features \\
   $PC_{ID}$    		& Selected features related to a parameter \\
   $UCM_{EFF}$ 			& Declares parameterized scenarios \\
   $CK_{EFF}$ 			& Relates parameters to features \\
   $PC_{EFF}$    		& Defines the domain value of parameters \\
   $UCM_{MOD}$ 			& Use case scenarios \\
   $CK_{MOD}$ 			& Each configuration item \\
   $PC_{MOD}$    		& Each selected feature \\
  \hline
  \end{tabular}
\end{center}
\end{table}

The use case model (UCM) defines the list of scenarios that might be
parameterized ($UCM_{EFF}$). Each step of a scenario ($UCM_{ID}$), indeed,
contributes to the definition of one join point in this weaver. The other
contributions come from the product configuration (PC), in the sense that the
domain values of a parameter is defined ($PC_{EFF}$) in the product specific
features; and from the configuration knowledge (CK), which is used for relating
parameters to features ($CK_{EFF}$).

% ---
% Scenario composition weaver
% ---

\subsection{Variability in control flow}\label{sub:sc-weaver}

This source of variability occurs when a particular pattern of interaction (a use
case scenario) varies from one product to another. Differently from PLUSS and
PLUC, in our approach we use the notion of $advices$ to modularize the variant
behavior of a scenario. An advice customizes the specification of a feature, by
means of extending the common behavior of existing scenarios with additional
steps. The flow of events of an advice can be inserted before or after the steps
referenced by its pointcut clause, which can be either the $step\ id$ or
$annotations$ assigned to different steps.

The function \emph{evaluateAdvice} is the reference implementation of this
weaver. Basically, this mechanism takes as input the name of an advice to be
evaluated; the SPL use case model ($spl$), which defines both use cases and
aspectual use cases; and the $product$ being generated. Then, it evaluates the
advice, retrieving the steps in the product that match the pointcut clause of the
advice. Depending on the type of the advice (before or after), the composition of
the \emph{advice's flow of events} occurs before or after the matched steps.


\begin{code}
evaluateAdvice name spl product =
  evaluateAdvice' product advice
  where
  advice = head [a | a <- advices spl, (id a) == name]

evaluateAdvice' product advice =
  if(isBefore advice)
    then composeBefore product matchedSteps flow
    else composeAfter product matchedSteps flow
  where
  matchedSteps = match (product (pointCut advice))
  flow = scenarioOfAdvice (advice)
\end{code}

Below we show a concrete instance of the second line of the \emph{eShop}
configuration knowledge (Table~\ref{tab:eshop-ck}). Notice that the configuration
knowledge binds the first parameter of the \emph{evaluateAdvice} function.
Therefore, the configuration knowledge contributes to this source of variability
by relating features to advices.

\begin{code}
c3 = Configuration (``ShoppingCart'' 'And' ``Bonus'',
   evaluateAdvice(``ADV02''))
\end{code}

The model of this weaver is in Table~\ref{tab:sc-weaver}. The output is a new
configuration of the \emph{product specific use case model}, whose scenarios were
extended by alternative (or optional) flows of events. The extensions occur
before or after the steps that match ($O_{JP}$) the pointcut clause ($UCM_{ID}$)
of the advice, declared in the SPL use case model (UCM).

The effect of evaluating the input language ($UCM$) in the composition process is
to extend product specific scenarios that, before this activity, may not define
a concrete flow of events. As a consequence, the \emph{match} function plays a
fundamental role in this process, retrieving the steps in the use case model that
satisfy the pointcut clauses.

\begin{table}[hbt]
\begin{center}
\caption{Model of Scenario Composition Weaver} \label{tab:sc-weaver}
\begin{tabular}{p{0.7in}p{2.3in}}
   \hline\noalign{\smallskip}
  {\bf Element} & {\bf Description} \\
   \noalign{\smallskip}
   \hline
   \noalign{\smallskip}
   $o$               & Specific scenarios with extensions  \\
   $o_{jp}$          & Scenarios and steps of scenarios \\
   $L$               & \{UCM, CK, PC\} \\
   $UCM_{ID}$        & Pointcuts of declared advices \\
   $CK_{ID}$         & Mapping of features to advices \\
   $PC_{ID}$          & Selected features related to advices  \\
   $UCM_{EFF}$       & Provides declaration of advices  \\
   $CK_{EFF}$        & Relates features to advices \\
   $PC_{EFF}$    	 & Triggers advice selection \\
   $UCM_{MOD}$       & Advices \\
   $CK_{MOD}$        & Each configuration item \\
   $PC_{MOD}$        & Each selected feature \\
  \hline
  \end{tabular}
\end{center}
\end{table}

%==============================================================
% Esse bloco comentado foi movido da secao de motivating
% example
%==============================================================

%
% Although the semantics of each variability mechanism, expressed as weavers in
% our modeling framework, are described in next sections, here we discuss the
% semantics of the \emph{weaving process} (Figure~\ref{fig:weave-process}). The
% weaving process is responsible for generating a use case model that is specific to the
% product configuration. Therefore, the process takes into account a selection of
% features, which characterizes specific instances of a product line. In this
% process, the contribution of the configuration knowledge is fundamental, since
% it is responsible for relating feature expressions (writeen in propositional
% logic) to individual weavers.
%
% \begin{figure}[ht]
% \begin{code}
% type ConfigurationKnowledge = [Configuration]
%
% data Configuration  = Configuration {
%  exp :: FeatureExpression,
%  weavers :: [Weaver] 	
% }
%
% type Weaver = (SPL -> SPLMember) -> SPLMember
%
% weavingProcess spl fm pc ck =
%    stepRefinement [(w spl) | w <- ws] p
%    where
%     ws = concat [weavers c| c <- ck, eval pc (exp c)]
%     p = (emptyInstance spl fc)
%     stepRefinement l m = ...   	
% \end{code}
% \caption{Weaving Process' interpreter}
% \label{fig:wp-semantics}
% \end{figure}
%
% Figure ~\ref{fig:wp-semantics} shows our proposed configuration knowledge,
% represented as a list of the algebraic data type $(exp,\ weavers)$, and a valid
% interpreter for the weaving process. Basically,
% the interpreter evaluates a list of weavers ($ws$) that must be applied for
% the specific product configuration. In order to filter the list of weavers, it
% is necessary to verify  ($eval\ pc\ (exp\ c)$) which expressions ($exp\ c$) in
% the configuration knowledge are valid for a specific product configuration
% ($pc$).
%
% Each weaver is a function that takes as input a SPL model
% ($spl$) and a SPL member ($p$); and returns a refined
% version of the SPL member. At the begining, the SPL member is empty.
% The $stepRefinement$ function composes the sequence of weavers that must
% be applied. Therefore, supposing $ws = [h,g,f]$, the semantics of
% this hypothetical product would be given by:
%
% \begin{center}
% $ p\ =\ f\ (spl,\ g\ (spl,\ h\ (spl,\ emptyProduct)))  $
% \end{center}
%
% The next Section presents examples of each input model. All examples were
% extracted from the \emph{eShop} Product Line (briefly introduced in
% Section~\ref{sec:problem}).

