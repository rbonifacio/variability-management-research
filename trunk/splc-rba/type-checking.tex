\section{Type System}
\label{sec:type-checker}

One of the main concerns in our research work is \emph{type safety} in feature models, in order to prevent erroneous or undesirable analysis results. We consider a feature model well-typed if a number of well-formation constraints are obeyed. We present these rules in this section, both informally and using a formalization language with conventional notation mixed with the PVS language~\cite{Owre:2009aa}. Notice that this is a minimal set of constraints, as derived from our knowledge about the requirements for verifying that a selection of features is a valid member of a feature model.

We begin by providing a formal definition for feature models, which are composed of a root feature, relations, features and formulae. While \texttt{Feature} is an uninterpreted type -- with a name -- relation is a PVS datatype with four distinct classes: optional (\texttt{OPT\_REL}), mandatory (\texttt{MAND\_REL}), alternative (\texttt{ALT\_REL}) and Or-feature (\texttt{OR\_REL}). While the first two types are defined between two features, the latter are defined between a parent and a set of child features. Furthermore, we consider a set of formulae for defining constraints over the feature model (in this case, core formulae only, such as negation, conjunction and implication).

\bfoo{\small
  FM: type = [# 
    root: Feature,
    relations: set[Relation]
    features: set[Feature], 
    formulae: set[Formula] 
  #]

  Relation: datatype
  begin 
  	OPT_REL(p,c: Feature):OPT?:Relation
  	MAND_REL(p,c: Feature):MAND?:Relation
  	ALT_REL(p: Feature,c:set[Feature]):
  	  ALT?:Relation
  	OR_REL(p: Feature,c:set[Feature]):
  	  OR?:Relation
	end Relation
	
	Formula : datatype
    TRUE_FORMULA:TRUE?:Formula
    FALSE_FORMULA:FALSE?:Formula
    NAME_FORMULA(n: Name):NAME?:Formula
    NOT_FORMULA(f: Formula):NOT?:Formula
    AND_FORMULA(f0,f1: Formula):
        AND?:Formula
    IMPLIES_FORMULA(f0,f1:Formula):
        IMPLIES?:Formula
  end Formula
}\efoo%

A feature model is well typed iff its feature tree is well formed and its constraints are well typed. A feature tree must satisfy the following well-formedness rules:
\begin{itemize}
	\item there must exist exactly one root feature (already contemplated in the previous \texttt{FM} definition);
	\item features must form a tree, as a connected and acyclic graph;
	\item feature names must be unique;
	\item all relations are well formed.
\end{itemize}
%{\bf (F.)} Consider $f \in F$, where F is the set of features defined in a feature tree. If $f$ is a \emph{Basic-feature}, it will always be well typed. Otherwise, if $f$ is an \emph{Or-feature} or an \emph{Alternative-feature}, $f$ will be well typed iff $children (f) \neq \emptyset$. 

\bfoo{\small
  wellTyped(fm: FM): boolean =
    wellFormednessRules(fm) \cc{\wedge} 
    wellTypedFormulae(fm)

  wellFormednessRules(fm: FM): bool = 
    tree(fm) \cc{\wedge} uniqueFeatureNames(fm) \cc{\wedge}
    wellFormedRelations(fm)

}\efoo

For the \texttt{tree} predicate, two other auxiliary predicates must be valid: all features must constitute a graph that is both \emph{acyclic} and \emph{connected}; these predicates use the \texttt{children} function, which returns the transitive closure of the set of relations within the feature model. In addition, relations are well-formed when they relate the correct number of features for the considered relation type. For instance, alternative relations must relate at least one parent and one child feature.


\bfoo{\small
  tree(fm: FM): bool = 
      acyclic(fm) \cc{\wedge} connected(fm)
  
  acyclic(fm:FM): bool = 
  	\cc{\forall}f:Feature \cc{\bullet} f \cc{\in} features(fm) \cc{\Rightarrow}
  	    f \cc{\notin} children(f)
  
  connected(fm:FM): bool = 
  	\cc{\forall}f:Feature \cc{\bullet} f \cc{\in} features(fm) \cc{\Rightarrow}
  	    f \cc{\notin} children(root(fm))
  
  uniqueFeatureNames(fm: FM): bool =
    \cc{\forall}f1,f2: Feature \cc{\bullet} 
      f1\cc{\neq}f2 AND f1 \cc{\in} features(fm) \cc{\wedge} 
      f2 \cc{\in} features(fm) \cc{\Rightarrow} f1=f2

  wellFormedRelations(fm: FM): bool =
    \cc{\forall}r: Relation \cc{\bullet} r \cc{\in} relations(fm) \cc{\wedge}
      (ALT?(r) OR OR?(r)) \cc{\Rightarrow}
        \cc{\exists}f:Feature \cc{\bullet} 
          f \cc{\in} features(fm) \cc{\wedge} f \cc{\in} children(r)
}\efoo%

%It is important to notice that a FM must not be a graph. 
Type correctness of formulae is established when they refer only to features declared in the feature tree (\texttt{NAME\_FORMULA} clause). The predicates over formula typing are conditioned to well formed feature tree (denoted by PVS predicate subtypes in the predicate header).

\bfoo{\small
  wellTypedFormulae(fm: \{featMod: FM | 
    wellFormednessRules(featMod)\}): boolean =
      \cc{\forall}f:Formula: f \cc{\in} formulae(fm) \cc{\Rightarrow} 
          wellTyped(fm,f)

  wellTyped(fm:\{featMod:FM | 
    wellFormednessRules(featMod)\},
    f:Formula):boolean =
    cases f of 
      TRUE_FORMULA: true,
      FALSE_FORMULA: true,
      NAME_FORMULA(n): n \cc{\in} names(fm),
      NOT_FORMULA(f1): wellTyped(fm,f1),
      AND_FORMULA(f1,f2): 
        wellTyped(fm,f1) \cc{\wedge} 
        wellTyped(fm,f2),
      IMPLIES_FORMULA(f1,f2): 
        wellTyped(fm,f1) \cc{\wedge} 
        wellTyped(fm,f2)
    endcases

}\efoo


%\begin{figure*}[th]
%\begin{prooftree}
%\AxiomC{FT}
%\AxiomC{CT}
%\AxiomC{SAT}
%\LeftLabel{Feature Model:}
%\TrinaryInfC{FM}
%
%\end{prooftree}
%
%\begin{prooftree}
%
%\AxiomC{Root}
%\AxiomC{Names}
%\AxiomC{$checkFeature(f), where f \in features$}
%\LeftLabel{Feature Tree:}
%\TrinaryInfC{FT}
%
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$names(CS) \in names(FT)$}
%\LeftLabel{Global Constraints:}
%\UnaryInfC{CT}
%\end{prooftree}
%
%
%\begin{prooftree}
%\AxiomC{$type(root(FT)) == Mandatory$}
%\LeftLabel{Root feature:}
%\UnaryInfC{Root}
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$f1,f2 \in features, name (f1) == name (f2) \Rightarrow f1 == f2 $}
%\LeftLabel{Unique names:}
%\UnaryInfC{Names}
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$f \in features, group(f) == (OrFeature \vee AltFeature), children (f) \neq \emptyset $}
%\LeftLabel{Feature:}
%\UnaryInfC{checkFeature(f)}
%\end{prooftree}
%
%\begin{prooftree}
%\AxiomC{$isSatisfiable(constraints(FT) \cup constraints(CT))$}
%\LeftLabel{Satisfiability:}
%\UnaryInfC{SAT}
%\end{prooftree}
%
%\label{fig:inference-rules}
%\caption{Inference rules for the feature model type checking}
%\end{figure*}


%The inference rules for the feature model type checker are present in Figure~\ref{fig:inference-rules}.

% semântica estatica
%A feature model is well-formed if its formulae are well-typed, as formalized next. The inference rules stating when a formula is well-typed is presented in Table~\ref{formula-welltyped}. 
%explicando a notacao do sistema de tipos
%The symbol ~\(\Gamma\) represents the context. The notation ~\( \Gamma \vdash \) \emph{f} means that \emph{f} is well-typed in ~\(\Gamma\). 

%\begin{table}[t]\centering

%$\begin{array}{c}
%{\prooftree 

%\justifies 
%  \Gamma \vdash \truee

%\using
%true
%\endprooftree}

%\qquad

%{\prooftree 

%\justifies 
%  \Gamma \vdash \truee

%\using
%false
%\endprooftree}
%\end{array}$

%\vspace{0.2cm}

%$\begin{array}{c}

%{\prooftree 

%  n \in \Gamma
%  
%\justifies 
%  \Gamma \vdash n

%\using
%name
%\endprooftree}

%\qquad

%{\prooftree 

%  \Gamma \vdash f
%  
%\justifies 
%  \Gamma \vdash \neg f

%\using
%not
%\endprooftree}
%\end{array}$

%\vspace{0.2cm}

%$\begin{array}{c}
%{\prooftree 

%  \Gamma \vdash f, \:
%  \Gamma \vdash g \:
%  
%\justifies 
%  \Gamma \vdash f \wedge g

%\using
%and
%\endprooftree}

%\qquad

%{\prooftree 

%  \Gamma \vdash f, \:
%  \Gamma \vdash g \:
%  
%\justifies 
%  \Gamma \vdash f \Rightarrow g

%\using
%implies
%\endprooftree}
%\end{array}$

%\caption{Well-Typed Formulae}
%\label{formula-welltyped}
%\end{table}


%\begin{lstlisting}[language=Java, label=source-push-down, caption={Uma especificacao parecida com PVS}]
%Name: theory
%begin
%  Name: type
%end Name
%
%Feature: theory
%begin importing Name
%  Feature: type
%  name: [Feature->Name]
%end Name
%
%Relation: datatype
%begin importing Feature
%  OPT_REL(p,c: Feature): OPT?: Relation
%  MAND_REL(p,c: Feature): MAND?: Relation
%  ALT_REL(p: Feature, 
%          c:set[Feature]): ALT?: Relation
%  OR_REL(p: Feature, 
%         c:set[Feature]): OR?: Relation
%end Relation
%
%Formula : datatype
%begin importing Name
%  TRUE_FORMULA:TRUE?:Formula
%  FALSE_FORMULA:FALSE?:Formula
%  NAME_FORMULA(n: Name):NAME?:Formula
%  NOT_FORMULA(f: Formula):NOT?:Formula
%  AND_FORMULA(f0,f1: Formula):AND?:Formula
%  IMPLIES_FORMULA(
%    f0,f1:Formula):IMPLIES?:Formula
%end Formula
%
%FeatureModel: theory
%begin importing Name, Feature, 
%                Relation, Formula
%  FM: type = [# 
%    root: Feature,
%    relations: set[Relation]
%    features: set[Feature], 
%    formulae: set[Formula] 
%  #]
%  Configuration: type = [# 
%    value: set[Name] 
%  #]
%  names(fm: FM): set[Name] = 
%  {n: Name | exists f:Feature | 
%    features(fm)(f) AND name(f) = n} 
%end FeatureModel
%
%FeatureModelTypeSystem: theory
%
%-- preciso pensar como especificar isso
%  
% 
%  wellTyped(fm: FM): boolean =
%    wellFormedRules(fm) AND 
%    wellTypedFormulae(fm)
%end FeatureModelTypeSystem
%\end{lstlisting}
