\section{Introduction}

% in this section, we should present
% a short motivation for the paper and
% describe, clearly, how are the main
% of the work.

Aspect-Oriented Programming (AOP)~\cite{kiczales-ecoop-1997} has
been proposed as a technique for modularizing crosscutting concerns.
Logging, distribution, tracing, security, and transactional
management are accepted as examples of crosscutting concerns well
addressed by AOP. Yet, AOP seems to produce modularity problems. In
this context, several authors argue that in order to reason about
classes it is necessary to consider all aspects
implementations~\cite{sullivan-sigsoft-2005, leavens-observers-2002,
steiman-sigplan-2006}.

In fact, by referring to classes implementation details in aspects,
one can inhibit modular reasoning and compromise the changeability,
requiring class modifications to be fully aware of the aspects
affecting the class. Therefore, constructs aimed to support
\emph{crosscutting modularity} might actually break \emph{class
modularity}~\cite{ribeiro-sbes-07}. In the presence of aspects,
class modularity is compromised because, when evolving a class, it
might be necessary to analyze the implementation of existing
aspects, instead of analyzing only the class and the interface of
other referred classes.

This weakness can be mitigated by using adequate Design Rules
(Section~\ref{sec:software-modularity}) between classes and aspects,
which are necessary to reduce such new dependencies in AO systems.
Design rules are not just guidelines and recommendations: they
generalize the notion of information hiding interfaces and must be
rigorously obeyed.

The use of Design Rules has been discussed in other
works~\cite{sullivan-fse-2005, vlopes-aosd-2005, lopes-taosd-2006}
but none of these works propose a final solution where they can be
described in an unambiguous manner and utilized not only for
checking but as a guideline for developers since the initial phases
of the development process.

The main contribution of this paper is a Design Rule specification
language (Section~\ref{sec:drlang}) that improves the modularity of
AO systems. This language supports a more modular design to decouple
classes and aspects through the establishment of the minimum
requirements necessary to work in parallel. For instance, the
language allows designers to write the (un)expected join points and
to define the responsibilities of both class and aspect developers.
These requirements are checked statically. Beyond all the advantages
cited so far, the usage of a specific language for this purpose
brings the following advantages:

\begin{itemize}

    \item Allows the description of the Design Rules in a simple and unambiguous manner,
    making easier the development of mechanisms for an automatic
    checking of the rules in the written code;

    \item Provides a guideline to be utilized since the initial development phases
    of the components, specifying the essential constructions so that each developed
    component can have the proper functionality.

    \item Our language provides declarative statements, being easy to read and write
    the Design Rules.

\end{itemize}

The language was initially evaluated in a real system called Health
Watcher~\cite{} (Section~\ref{sec:aop-issues}). The results consist
of a simpler and unambiguous specification. We have defined Design
Rules by using our language and Crosscutting Programming Languages
(XPIs)~\cite{sullivan-ieee-sw-2006} in the aforementioned system.
A comparison between these approaches is presented in
Section~\ref{sec:evaluation}, depicting the advantages and
disadvantages of our approach. For example: our language seems to
improve the opportunities for reuse in comparison to XPIs. On the
other hand, the set of rules defined by XPIs may be bigger due to
natural language capabilities.
