\section{Evaluation}

% Discuss the benefits of applying the DR language in different case studies
% - Health watcher
% - choose one of the cases: TaRGeT, Games, Mobile Media, FLIP, \ldots
% Evaluate the benefits based on metrics
% - Concern metrics or Lattix Metrics

In this section we evaluate our language for specifying design rules
in AO systems. Basically, we discuss advantages and disadvantages of
using our approach when compared to other ones like Crosscutting
Programming Interfaces (XPIs). In what follows, we describe the
details of our evaluation:

%\begin{itemize}
%    \item[$\square$] hhh
%    \item[$\square$] aaa
%\end{itemize}

\subsection{Auditing Concern}

The auditing concern must be triggered when inserting, removing,
updating, or searching for a complaint.

Two teams working in parallel without design rules: the first one
works on the base code (the ComplaintRepository) and the second one
works on the auditing concern. Such a concern is implemented as an
aspect.

\scriptsize
\begin{lstlisting}[frame=single, caption={Complaint Repository implementation.},label=lst:complaint-repository, language=Java]
public class ComplaintRepository implements IComplaintRepository {

    public int insert(Complaint c) throws RepositoryException,
            ObjectAlreadyInsertedException {

    }

    public void update(Complaint c) throws RepositoryException,
            ObjectNotFoundException {

    }

    public void remove(int id) throws RepositoryException,
            ObjectNotFoundException {

    }

    public Complaint search(int id) throws RepositoryException,
            ObjectNotFoundException {

    }

}
\end{lstlisting}
\normalsize

Aspect for implementing the auditing concern:

\scriptsize
\begin{lstlisting}[frame=single, caption={Auditing Aspect.},label=lst:auditing-aspect, language=Java]
public aspect AuditingAspect {

    pointcut auditWhen():
           execution(int ComplaintRepository.insert(Complaint)
        || execution(void ComplaintRepository.update(Complaint)
        || execution(void ComplaintRepository.remove(int)
        || execution(Complaint ComplaintRepository.search(int)

    after() returning(): auditWhen() {
        // audit code.
    }

}
\end{lstlisting}
\normalsize

In the meanwhile, suppose that the teams are working on their
respective concerns (the repository and the auditing concerns). Now,
suppose that the team of the repository changes the following:

\begin{itemize}
    \item the insert method returns void instead of int; and

    \item the remove and search methods should take as parameter the
    Complaint object instead of an id.
\end{itemize}

Such changes might break the aspects...

% =================================== até aqui entraria na seção 2...

% ===== seção 4

Design Rule:

\scriptsize
\begin{lstlisting}[frame=single, caption={Auditing Design Rule.},label=lst:auditing-dr, language=Java]
dr AuditingDesignRule {

    class ComplaintRepository {

        public int insert(Complaint c) throws RepositoryException,
                ObjectAlreadyInsertedException {}

        public void update(Complaint c) throws RepositoryException,
                ObjectNotFoundException {}

        public void remove(int id) throws RepositoryException,
                ObjectNotFoundException {}

        public Complaint search(int id) throws RepositoryException,
                ObjectNotFoundException {}

    }

    aspect AuditingAspect {

        pointcut auditWhen():
            execution(int ComplaintRepository.insert(Complaint)
            || execution(void ComplaintRepository.update(Complaint)
            || execution(void ComplaintRepository.remove(int)
            || execution(Complaint ComplaintRepository.search(int)

        % precisa do args aqui...??? Acho que sim...

        after() returning(): auditWhen() {
            xcall(void Auditing.auditComplaint(Complaint));
        }

    }

}
\end{lstlisting}
\normalsize

XPI of this example:

\textbf{Observação para colocar no texto: a XPI garante que não há
chamadas fora do aspecto. No entanto, ela não garante:}

\begin{itemize}
    \item Que ocorre realmente uma chamada para auditComplaint;
    \item O local exato dessa chamada (dentro de um aspecto, por exemplo).
\end{itemize}

\scriptsize
\begin{lstlisting}[frame=single, caption={Auditing XPI.},label=lst:auditing-xpi, language=Java]
public aspect AuditingXPI {

    pointcut auditWhen():
        execution(int ComplaintRepository.insert(Complaint)
        || execution(void ComplaintRepository.update(Complaint)
        || execution(void ComplaintRepository.remove(int)
        || execution(Complaint ComplaintRepository.search(int)

    pointcut callToAudit(): call(void Auditing.auditComplaint(Complaint));

    declare error: (callToAudit() && !within(AuditingXPI)):
        "Contract violation: the auditComplaint method can not
        be called outside the aspect AuditingXPI";

}
\end{lstlisting}
\normalsize

In order to guarantee the contract that classes, aspects and their
respective methods and advices must exist, we can informally
document it like a prose, as mentioned in~\cite{sss}. Obviously, in
this case the contract is not verified by using the AspectJ
compiler, for instance.

However, we can guarantee the aforementioned contract by using
Aspect-Aware interfaces~\cite{sss}. Figure TAL illustrates that when
a pointcut does not match any piece of code, the compiler emits a
warning to the developer. Such a warning might be used to alert the
developer that some method must exist, for example.

\textbf{Observação para colocar no texto:}

As marcações de AJDT (did not match) pode nos ajudar a identificar
classes ou métodos que não existem. Mas elas não ajudam a
identificar que determinados aspectos ou advices existem.

Com quantificação, a AJDT consegue fazer as marcações. No entanto,
ao remover um join point que é capturado pelo aspecto, nenhum erro é
apresentado (ou seja, não há garantias que um determinado join point
existe ou não).

\subsection{Transaction Concern}

All methods of the HealthWatcherFacade must have transaction
management. In this case, due to the crosscutting nature of this
concern throughout the methods, we can use aspects to modularize it,
as showed in Listing TAL.

\scriptsize
\begin{lstlisting}[frame=single, caption={Transaction Management Aspect.},label=lst:transaction-aspect, language=Java]
public aspect HWTransactionManagement {

    pointcut transactionalMethods(): execution(* HealthWatcherFacade.*(..));

    after() returning: transactionalMethods()  {
        // ta errado... não é a interface
        IPersistenceMechanism.commitTransaction();
    }

    after() throwing: transactionalMethods()  {
        IPersistenceMechanism.rollbackTransaction();
    }

    before(): transactionalMethods() {
        IPersistenceMechanism.beginTransaction();
    }

}
\end{lstlisting}
\normalsize

\subsection{Concurrency Concern}

Section TAL showed the concurrency concern implemented as an aspect.
All methods of the \emph{EmployeeRepository} were synchronized by
the \emph{SynchronizationAspect}. In what follows, we present design
rules and XPIs to avoid modularity problems.

\scriptsize
\begin{lstlisting}[frame=single, caption={Concurrency Design Rule.},label=lst:concurrency-dr, language=Java]
dr Concurrency {

    class EmployeeRepository {

    }

    aspect SynchronizationAspect {

        pointcut concurrency(): execution(* EmployeeRepository.*(..));

        Object around(): concurrency() {

        }

    }

}
\end{lstlisting}
\normalsize

\subsection{Product Line Games}
