\section{Evaluation}

% Discuss the benefits of applying the DR language in different case studies
% - Health watcher
% - choose one of the cases: TaRGeT, Games, Mobile Media, FLIP, \ldots
% Evaluate the benefits based on metrics
% - Concern metrics or Lattix Metrics

In this section we evaluate our language for specifying design rules
in AO systems. Basically, we discuss advantages and disadvantages of
using our approach when compared to other ones like Crosscutting
Programming Interfaces (XPIs). In what follows, we describe the
details of our evaluation:

%\begin{itemize}
%    \item[$\square$] hhh
%    \item[$\square$] aaa
%\end{itemize}

\subsection{Auditing Concern}


Design Rule:

\scriptsize
\begin{lstlisting}[frame=single, caption={Auditing Design Rule.},label=lst:auditing-dr, language=Java]
dr AuditingDesignRule {

    class ComplaintRepository {

        public int insert(Complaint c) throws RepositoryException,
                ObjectAlreadyInsertedException {}

        public void update(Complaint c) throws RepositoryException,
                ObjectNotFoundException {}

        public void remove(int id) throws RepositoryException,
                ObjectNotFoundException {}

        public Complaint search(int id) throws RepositoryException,
                ObjectNotFoundException {}

    }

    aspect AuditingAspect {

        pointcut auditWhen():
            execution(int ComplaintRepository.insert(Complaint)
            || execution(void ComplaintRepository.update(Complaint)
            || execution(void ComplaintRepository.remove(int)
            || execution(Complaint ComplaintRepository.search(int)

        % precisa do args aqui...??? Acho que sim...

        after() returning(): auditWhen() {
            xcall(void Auditing.auditComplaint(Complaint));
        }

    }

}
\end{lstlisting}
\normalsize

XPI of this example:

\textbf{Observação para colocar no texto: a XPI garante que não há
chamadas fora do aspecto. No entanto, ela não garante:}

\begin{itemize}
    \item Que ocorre realmente uma chamada para auditComplaint;
    \item O local exato dessa chamada (dentro de um aspecto, por exemplo).
\end{itemize}

\scriptsize
\begin{lstlisting}[frame=single, caption={Auditing XPI.},label=lst:auditing-xpi, language=Java]
public aspect AuditingXPI {

    pointcut auditWhen():
        execution(int ComplaintRepository.insert(Complaint)
        || execution(void ComplaintRepository.update(Complaint)
        || execution(void ComplaintRepository.remove(int)
        || execution(Complaint ComplaintRepository.search(int)

    pointcut callToAudit(): call(void Auditing.auditComplaint(Complaint));

    declare error: (callToAudit() && !within(AuditingXPI)):
        "Contract violation: the auditComplaint method can not
        be called outside the aspect AuditingXPI";

}
\end{lstlisting}
\normalsize

In order to guarantee the contract that classes, aspects and their
respective methods and advices must exist, we can informally
document it like a prose, as mentioned in~\cite{sss}. Obviously, in
this case the contract is not verified by using the AspectJ
compiler, for instance.

However, we can guarantee the aforementioned contract by using
Aspect-Aware interfaces~\cite{sss}. Figure TAL illustrates that when
a pointcut does not match any piece of code, the compiler emits a
warning to the developer. Such a warning might be used to alert the
developer that some method must exist, for example.

\textbf{Observação para colocar no texto:}

As marcações de AJDT (did not match) pode nos ajudar a identificar
classes ou métodos que não existem. Mas elas não ajudam a
identificar que determinados aspectos ou advices existem.

Com quantificação, a AJDT consegue fazer as marcações. No entanto,
ao remover um join point que é capturado pelo aspecto, nenhum erro é
apresentado (ou seja, não há garantias que um determinado join point
existe ou não).

\subsection{Transaction Concern}

All methods of the HealthWatcherFacade must have transaction
management. In this case, due to the crosscutting nature of this
concern throughout the methods, we can use aspects to modularize it,
as showed in Listing TAL.

\scriptsize
\begin{lstlisting}[frame=single, caption={Transaction Management Aspect.},label=lst:transaction-aspect, language=Java]
public aspect HWTransactionManagement {

    pointcut transactionalMethods(): execution(* HealthWatcherFacade.*(..));

    after() returning: transactionalMethods()  {
        // ta errado... não é a interface
        IPersistenceMechanism.commitTransaction();
    }

    after() throwing: transactionalMethods()  {
        IPersistenceMechanism.rollbackTransaction();
    }

    before(): transactionalMethods() {
        IPersistenceMechanism.beginTransaction();
    }

}
\end{lstlisting}
\normalsize

\subsection{Concurrency Concern}

Section TAL showed the concurrency concern implemented as an aspect.
All methods of the \emph{EmployeeRepository} were synchronized by
the \emph{SynchronizationAspect}. In what follows, we present design
rules and XPIs to avoid modularity problems.

\scriptsize
\begin{lstlisting}[frame=single, caption={Concurrency Design Rule.},label=lst:concurrency-dr, language=Java]
dr Concurrency {

    class EmployeeRepository {

    }

    aspect SynchronizationAspect {

        pointcut concurrency(): execution(* EmployeeRepository.*(..));

        Object around(): concurrency() {

        }

    }

}
\end{lstlisting}
\normalsize

\subsection{Product Line Games}
