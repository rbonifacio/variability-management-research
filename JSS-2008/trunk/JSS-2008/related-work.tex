\section{Related work}

% Compare our work with relevant ones
% - open modules
% - XPIs
% ..
% We conclude that we should improve this section

\subsubsection{Open Modules}

Open Modules is an approach for dealing with modularity issues in 
AOP~\cite{aldrich-ecoop-05}. Besides exposing data structures and 
functions, Open Modules' interfaces can also expose pointcuts denoting 
internal semantic of events. Clients of these modules are able to advice 
only exported pointcuts. Moreover, by exporting a pointcut, the module's 
developer is compromised to maintain the semantics of that pointcuts, 
which, in fact, mitigates the fragile pointcut problem. 

\ldots

TODO: Revisar o texto a seguir. A idehia eh simplificah-lo.

The Crosscut Programming Interfaces (XPIs) is one attempt for defining design rules between aspects and 
advised code~\cite{sullivan-sigsoft-2005,sullivan-ieee-sw-2006}. Such interfaces specify which are the exposed 
join-points of a base code. Although an abstract XPI representation was provided in~\cite{sullivan-sigsoft-2005}, Griswold et. al  
presented how to implement crosscutting interfaces as syntactic constructs of AspectJ~\citet{sullivan-ieee-sw-2006}. 
Based on this approach, design rules are documented using \emph{abstract pointcut descriptions} and constraints 
applied to the base code. These constraints might be written as \emph{declare warning} (or \emph{declare error}) constructs
or just as comments in the source code (when a constraint can not be expressed as a \emph{declare warning} 
or \emph{declare error}). 

XPIs authors argue that an important characteristic of their approach is that it
does not require any new construct in the AspectJ language and there is no
restriction to the pointcut visibility. In fact, this characteristic encourage
the use of XPIs in environments that are already using the AspectJ language.
However, most of the constraints required for defining the responsibilities of
both class developers and aspect developers can not be checked using the proposed
XPI language. Consequently, it is not possible to guarantee, at least
automatically, if certain design rules are being obeyed. For instance, we can not
express, using AspectJ constructs, that a call to a method \emph{must} occurs
within the flow of another method. Actually, we can define such a pointcut, but
if it does not exist,  no error is reported by the AspectJ compiler. Actually,
pointcut constructs in AspectJ were proposed for specifying points of execution
that should be augmented by advices. They were not proposed for specifying
restrictions applied for base code developing.

Aiming at specifying restrictions in base code using AspectJ like languages,
developers are able to check if a {\bf non desirable} pointcut occurs in the
source code (by means of \emph{declare error} or {declare warning} constructs).
However, there is no construct which can be used for specifying that a specific
pointcut {\bf must} occur in the source code. However, in order to improve
modularity between crosscutting and base decisions, it is necessary to define
what is expected from both teams (not only what aspect developers require, as
supported by XPIs).

Therefore, we propose a new design rule language that can be used for specifying
interfaces between aspects and advised code. In what follows, we present the
syntax and semantics of our proposed language. Then, in Section~\ref{}, we
present an evaluation though different case studies.

%However, Open Modules do not offers mechanims for describing which 
%are the responsabilities of aspect developers. As a consequence, 
%module developers are still able to implement part of a concern 
%assigned for a different team and they can not assume the existence 
%of any behavior expected to be modularized as an aspect. 

