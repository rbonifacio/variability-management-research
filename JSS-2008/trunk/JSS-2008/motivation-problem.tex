\section{Motivation Problem}

The concept of modularity applied to software development was first
introduced by Parnas~\cite{parnas-on_the_criteria-cacm1972}. Such
concept is still used as a guide for architects and is being applied
in another areas. Modularity is closely related to design decisions
that decompose and organize the system into a set of modules. The
following qualities attributes are expected in a modular design:

\begin{description}

\item[Comprehensibility] A modular design allows developers to
understand a module looking only at: (1) the implementation of the
module itself; and (2) the interfaces of the other modules
referenced by it\footnote{This comprehensibility degree is also
known as \emph{modular reasoning}.}.

\item[Changeability] A modular design enables local
changes. If changes are necessary in the internal implementation of
a module \emph{A}, the other modules that depend exclusively on
\emph{A's interface} will not need to change, since there is no
modification in the module interface.

\item[Parallel development] After the specification of the module
interfaces, a modular design enables the parallel development of
modules. Different teams might only focus in their own modules
development, reducing the time-to-market and the need of
communication.

\end{description}

Parnas proposed the \emph{information hiding} principle as the
criteria to be used in decomposition of systems into modules.
According to Parnas, the parts of a system that are more likely to
changes must be hidden into modules with stable interfaces.

Aspect-Oriented Programming was proposed to modularize crosscutting
concerns. However, constructions supported by
AspectJ~\cite{kiczales-CACM2001} like languages can produce high
coupling between the base code and the aspects, which may compromise
the aforementioned modular criteria. In this section, we illustrate
this problem through some examples.

\subsection{Example 1}

Suppose the requirement of synchronizing (concurrency management)
all methods of a class. Such requirement consists of encompassing
with synchronized blocks the bodies of all methods.
Listing~\ref{lst:ao-synchronizing} illustrates an implementation of
this in AspectJ.

\scriptsize
\begin{lstlisting}[frame=single, caption={Concurrency concern tangled and scattered in EmployeeRepository.},label=lst:ao-synchronizing, numbers=left, language=Java]
public aspect LocalSynchronization {

    Object around(Object o): this(o) && execution(* EmployeeRepository.*(..)) {
        synchronized(o) {
            return proceed(o);
        }
    }
}
\end{lstlisting}
\normalsize

Now, suppose a new feature intended to counting the number of
Employees registered in a given profile. Such feature might be
implemented as a new method in the \emph{EmployeeRepository} class
(Listing~\ref{lst:new-method}). Notice that this method does not
need to be synchronized, since it does not manipulate a specific
instance of \emph{Employee}.

\scriptsize
\begin{lstlisting}[frame=single, caption={A new method for counting the number of Employees.},label=lst:new-method, numbers=left, language=Java]
public class EmployeeRepository {

    public int getNumberOfEmployees(Profile profile) {
        // Business logic to count the number of Employees
    }

}
\end{lstlisting}
\normalsize

If a class developer oblivious about the \emph{LocalSynchronization}
aspect decides to implement the \emph{getNumberOfEmployees} method,
at least three problems can occur:

%However, the application will not behave as presumed, since the
%method will be synchronized by the aspect.

\begin{enumerate}

    \item the methods created by the class developer might not need concurrency management,
    but they will be synchronized by the aspect;

    \item if the class developer, oblivious about the aspect,
    implements concurrency management on methods class, these methods
    would be synchronized twice; and

    \item depending on how the synchronization approaches are implemented
    by the aspect and class developers, together they might lead the system
    to a dealock or a livelock situation~\cite{lea-java-coop-1999}.

\end{enumerate}

In such cases, the expected behavior of the system could be
compromised, since some additional synchronization would be created
or, even worst, the system might reach a dealock or a livelock.

The situation above exposes that problems of modularity have
occurred: (1) the comprehensibility is compromised, since two
modules should be studied in order to understand the concern; and
(2) the parallel development is problematic, because one developer
can implement unintended behavior into a module which, although it
is not under his responsibility, might break the system.

%Suppose a new feature that requires counting the number of Employees
%registered in a given profile. Such feature might be implemented as
%a new method in the \emph{EmployeeRepository} class
%(Listing~\ref{lst:ds}). This method does not need to be
%synchronized, since it does not manipulate a specific instance of
%\emph{Employee}. However, the application will not behave as
%presumed, since the method will be synchronized by the aspect.
%
% COLOCAR A CLASSE TODA??? TEM ESPAÇO MESMO...
%
%\scriptsize
%\begin{lstlisting}[frame=single, caption={A new method for counting the number of Employees.},label=lst:ds, numbers=left, language=Java]
%public class EmployeeRepository {
%
%    public int getNumberOfEmployees(Profile profile) {
%        // Business logic to count the number of Employees
%    }
%
%}
%\end{lstlisting}
%\normalsize

\subsection{Example 2}

Another example of modularity issue might arise when a team is
assigned to develop a crosscutting concern and another team is
assigned to develop the base concerns of a system. In order to
reduce the time to market, it may be desirable to develop both
concerns in parallel. However, without the use of a clear interface
between those concerns, a lot of communication might be required,
which, in fact, compromises the parallel development.

When reasoning about modularity in software engineering,
the benefit of parallel development is frequently not considered. Even after
Parnas has claimed that modularity is more than program structure. Actually, 
his view of modularity is related to the assignment of development 
activities, which, of course, may be reflected in the program
structure~\cite{parnas-icse-03}.

\begin{quote}\emph{
My early work clearly treated modularisation as a design
issue, not a language issue. A module was a work assignment,
not a subroutine or other language element. Although
some tools could make the job easier, no special tools were
needed to use the principal, just discipline and skill.}
(D. Parnas)
\end{quote}


% include the parnas review of modularity
% read a bit more about the steimann discussion on AOP modularity
% we need a clear interface for both aspect and base code....

A similar view of modularity was presented by Baldwin and
Clark~\cite{clark-design-rules-book}. They proposed a theory that 
considers a \emph{modular design} as a key factor for innovation in 
different domains (hardware, software, and so on). Moreover, they 
observed that a modular design reduces the communication paths among 
design decisions, in such a way that unities of work can be developed 
in parallel. 

For instance, supposing that a team is responsible for developing
the use cases related to the \emph{complaint management} concern (a core concern
of Health Watcher system~\cite{soares-oopsla-02}); and another team is responsible
for an auditing concern that must be triggered whenever a change in a 
complaint occurs. Without a clear interface stating which are the relevant 
complaint changes (the set of join-points) and how these join-points should be
written by the complaint management team, any increment in the core concern
must be communicated to the auditing team. Consequently, it is difficult to
implement the auditing concern at the same time that the complaint management 
concern is being developed. Although these concerns can be encapsulated in 
single unities, there is no modular design in this case. 

We can represent this kind of dependence by means of Design Structure
Matrices (DSMs). DSMs are used to visualize dependencies among design 
parameters, which correspond to any decision that needs to be made along the 
product design. Parameters are disposed in both rows and columns of a matrix.
The notion of dependency, represented as a 'x' mark in the matrices, arises
whenever a design decision depends on another. For
instance, consider the DSM depicted in Figure~\ref{dsm:hw01}, which represent
some design parameters and respective dependencies of the Health Watcher
system. Based on this DSM, we can realize that decisions regarded to the
complaint implementation (row 5) depends on decisions about complaint 
requirements (dependence row 5, column 2), about architectural
decisions~\footnote{Examples of architectural decisions for the Health Watcher
system are the selected style (layers), patterns, and technologies for each
layer or concern (presentation, distribution, persistence, and so on)} 
(dependence row 4, column 4), and about the auditing concern (dependence row 4,
column 6). This last dependency occurs because the team responsible for developing 
the \emph{complaint concern} have to know how to develop the extension points for 
the \emph{auditing concern}. Moreover, as we can observe in
Figure~\ref{dsm:hw01}, the auditing implementation also depends on the
complaint implementation decisions, since changes in its implementation should
be notified to the auditing implementation team. In this way, there is a
cyclical dependency between complaint implementation and auditing
implementation -- a clear example of non modular design.

\begin{figure}[htb]
\centering
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|l|l|l|} \hline
  &  							& 1 	& 2 	& 3 	& 4 	& 5 	& 6	\\ \hline
1 & Goals and constraints		& 		&		&		&		&		&	\\ \hline
2 & Complaint requirements		& x		& 		& 		&   	&		&	\\ \hline 
3 & Auditing requirements		& x	 	&  		&  		&   	&		&	\\ \hline
4 & Architectural decisions		& x	 	& x		& 		&    	&		&	\\ \hline
5 & Complaint implementation	& 		& x		&		& x	 	&		& x	\\ \hline
6 & Auditing AO implementation	& 		&		& x		& 		& x		&	\\	\hline
\end{tabular}
\end{scriptsize}
\caption{DSM Analysis Health Watcher}
\label{dsm:hw01}
\end{figure}
  

Based on the information hidden principle, we should encapsulate the
dependences between complaint and auditing concerns in a special kind
of interface (a design rule). Design rules establish strict partitions 
of knowledge and effort at the outset of a design process. 
They are not just guidelines or recommendations: they must be rigorously 
obeyed in all phases of design and production~\cite{clark-design-rules-book}.
Applying design rules to our current example, we improve the design structure 
by removing the cyclical dependencies between complaint and auditing concerns. 
The reviewed DSM is presented in Figure~\ref{dsm:hw02}. Notice that a new parameter
(actually a design rule) was introduced (row 4) and all dependencies are bellow
the main diagonal (there is no more cyclical dependencies). 
 
\begin{figure}[htb]
\centering
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|} \hline
  &  								& 1 	& 2 	& 3 	& 4 	& 5 	& 6	& 7	\\ \hline
1 & Goals and constraints			& 		&		&		&		&		&	&	\\ \hline
2 & Complaint requirements 			& x		& 		& 		&   	&		&	&	\\ \hline 
3 & Auditing requirements			& x	 	&  		&  		&   	& 		&	&	\\ \hline 
4 & Architectural decisions			& x  	& x		& 		&   	&		& 	&	\\ \hline
5 & Auditing design rule			& 		& x		&   x	&		&		&	&	\\ \hline 
6 & Complaint implementation		& 		& x		&		&	x	& x		& 	&	\\ \hline
7 & Auditing AO implementation		& 		&		&	x	&   	& x		&	&	\\ \hline
\end{tabular}
\end{scriptsize}
\caption{DSM Analysis Health Watcher}
\label{dsm:hw02}
\end{figure}


This idea of defining interfaces between aspect code and adviced code is not
really new. Next, we present some proposals to solve this problem and discuss
how our approach improve existing works.

\subsection{Existing solutions}  

% ok, o problema realmente existe. mas ele não é novo. precisamos discutir que
% existem propostas para esse problema. Por outro lado elas não atendem.
% Possivelmente, um caminho é a idéia de que design-rules precisam ser
% rigorosamente seguidas. Sempre tenho dúvidas em relação a essa palavra:
% ``rigorosamente''
\subsubsection{XPIs}

\subsubsection{Open Modules}

\subsection{Aspect Box}
