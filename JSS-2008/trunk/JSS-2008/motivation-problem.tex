\section{Motivation Problem}

The concept of modularity applied to software development was first
introduced by Parnas~\cite{parnas-on_the_criteria-cacm1972}. Such
concept is still used as a guide for architects and is being applied
in another areas. Modularity is closely related to design decisions
that decompose and organize the system into a set of modules. The
following qualities attributes are expected in a modular design:

\begin{description}

\item[Comprehensibility] A modular design allows developers to
understand a module looking only at: (1) the implementation of the
module itself; and (2) the interfaces of the other modules
referenced by it\footnote{This comprehensibility degree is also
known as \emph{modular reasoning}.}.

\item[Changeability] A modular design enables local
changes. If changes are necessary in the internal implementation of
a module \emph{A}, the other modules that depend exclusively on
\emph{A's interface} will not need to change, since there is no
modification in the module interface.

\item[Parallel development] After the specification of the module
interfaces, a modular design enables the parallel development of
modules. Different teams might only focus in their own modules
development, reducing the time-to-market and the need of
communication.

\end{description}

Parnas proposed the \emph{information hiding} principle as the
criteria to be used in decomposition of systems into modules.
According to Parnas, the parts of a system that are more likely to
changes must be hidden into modules with stable interfaces.

Aspect-Oriented Programming was proposed to modularize crosscutting
concerns. However, constructions supported by
AspectJ~\cite{kiczales-CACM2001} like languages can produce high
coupling between the base code and the aspects, which may compromise
the aforementioned modular criteria. In this section, we illustrate
this problem through some examples.

\subsection{Example 1}

Suppose the requirement of synchronizing (concurrency management)
all methods of a class. Such requirement consists of encompassing
with synchronized blocks the bodies of all methods.
Listing~\ref{lst:ao-synchronizing} illustrates an implementation of
this concern in AspectJ applied to the \emph{EmployeeRepository}
class.

\scriptsize
\begin{lstlisting}[frame=single, caption={Aspect responsible for implementing the concurrency concern.},label=lst:ao-synchronizing, language=Java]
public aspect SynchronizationAspect {

    Object around(Object o): this(o)
            && execution(* EmployeeRepository.*(..)) {
        synchronized(o) {
            return proceed(o);
        }
    }
}
\end{lstlisting}
\normalsize

Now, suppose a new feature intended to count the number of employees
registered in a given profile. Such feature might be implemented as
a new method in the \emph{EmployeeRepository} class
(Listing~\ref{lst:new-method}).

\scriptsize
\begin{lstlisting}[frame=single, caption={A new method for counting the number of Employees.},label=lst:new-method, language=Java]
public class EmployeeRepository {

    public void insertEmployee(Employee employee) { ... }

    public void removeEmployee(Employee employee) { ... }

    public int getNumberOfEmployees(Profile profile) {
        // Business logic to count the number of Employees
    }

}
\end{lstlisting}
\normalsize

If a class developer oblivious about the
\emph{SynchronizationAspect} aspect decides to implement the
\emph{getNumberOfEmployees} method, at least three problems can
occur:

\begin{enumerate}

    \item the \emph{getNumberOfEmployees} method created by the class
    developer might not need concurrency management, but it will be
    synchronized by the aspect;

    \item if the class developer, oblivious about the aspect,
    implements concurrency management in the \emph{getNumberOfEmployees} method,
    such method would be synchronized twice; and

    \item depending on how the synchronization approaches are implemented
    by the aspect and class developers, together they might lead the system
    to a dealock or a livelock situation~\cite{lea-java-coop-1999}.

\end{enumerate}

In such cases, the expected behavior of the system could be
compromised, since some additional synchronization would be created
or, even worst, the system might reach a dealock or a livelock.

The situation above exposes that problems of modularity have
occurred: (1) the comprehensibility is compromised, since two
modules should be studied in order to understand the concern; and
(2) the parallel development is problematic, because one developer
can implement unintended behavior into a module which, although it
is not under his responsibility, might break the system.

In summary, we conclude that any unanticipated change in the class
may cause problems and the application might not behave as presumed.
Notice that we have a cyclical dependency situation: the aspect
depends on the class syntactically; and to change the class, the
developer must be aware about the aspect.
Figure~\ref{dsm:concurrency} illustrates such cyclical
dependency through a DSM (presented in Section~\ref{}), whereas
Figure~\ref{dsm:concurrency-drs} shows design rules coming into
play to remove the dependency between the aspects and class.

\begin{figure}[h]
    \begin{center}
        \subfigure[Cyclical Dependency between an aspect and a class.] {
            \begin{scriptsize}
            \begin{tabular}{|l|l|l|l|} \hline
                  &                             & 1     & 2     \\ \hline
                1 & SynchronizationAspect.aj    & \paintcell     & x     \\ \hline
                2 & EmployeeRepository.java     & x     & \paintcell      \\ \hline
            \end{tabular}
            \end{scriptsize}
            \label{dsm:concurrency}
        }
        \subfigure[Design Rules removing Cyclical Dependency.] {
            \begin{scriptsize}
            \begin{tabular}{|l|l|l|l|l|} \hline
                  &                             & 1     & 2    & 3 \\ \hline
                1 & Design Rules                &       &      &   \\ \hline
                2 & SynchronizationAspect.aj    & x     &      &   \\ \hline
                3 & EmployeeRepository.java     & x     &      &   \\ \hline
            \end{tabular}
            \end{scriptsize}
            \label{dsm:concurrency-drs}
        }
        \caption{Concurrency concern with/without Design Rules.}
    \end{center}
\end{figure}

\subsection{Example 2}

Another example of modularity issue might arise when a team is
assigned to develop a crosscutting concern and another team is
assigned to develop the base concerns of a system. In order to
reduce the time to market, it may be desirable to develop both
concerns in parallel. However, without the use of a clear interface
between those concerns, a lot of communication might be required,
which, in fact, compromises the parallel development.

When reasoning about modularity in software engineering,
the benefit of parallel development is frequently not considered. Even after
Parnas has claimed that modularity is more than program structure. Actually,
his view of modularity is related to the assignment of development
activities, which, of course, may be reflected in the program
structure~\cite{parnas-icse-03}.

\begin{quote}\emph{
My early work clearly treated modularisation as a design
issue, not a language issue. A module was a work assignment,
not a subroutine or other language element. Although
some tools could make the job easier, no special tools were
needed to use the principal, just discipline and skill.}
(D. Parnas)
\end{quote}


% include the parnas review of modularity
% read a bit more about the steimann discussion on AOP modularity
% we need a clear interface for both aspect and base code....

A similar view of modularity was presented by Baldwin and
Clark~\cite{clark-design-rules-book}. They proposed a theory that
considers a \emph{modular design} as a key factor for innovation in
different domains (hardware, software, and so on). Moreover, they
observed that a modular design reduces the communication paths among
design decisions, in such a way that unities of work can be developed
in parallel.

For instance, supposing that a team is responsible for developing
the use cases related to the \emph{complaint management} concern (a core concern
of Health Watcher system~\cite{soares-oopsla-02}); and another team is responsible
for an auditing concern that must be triggered whenever a change in a
complaint occurs. Without a clear interface stating which are the relevant
complaint changes (the set of join-points) and how these join-points should be
written by the complaint management team, any increment in the core concern
must be communicated to the auditing team. Consequently, it is difficult to
implement the auditing concern at the same time that the complaint management
concern is being developed. Although these concerns can be encapsulated in
single unities, there is no modular design in this case.

We can represent this kind of dependence by means of Design Structure
Matrices (DSMs). DSMs are used to visualize dependencies among design
parameters, which correspond to any decision that needs to be made along the
product design. Parameters are disposed in both rows and columns of a matrix.
The notion of dependency, represented as a 'x' mark in the matrices, arises
whenever a design decision depends on another. For
instance, consider the DSM depicted in Figure~\ref{dsm:hw01}, which represent
some design parameters and respective dependencies of the Health Watcher
system. Based on this DSM, we can realize that decisions regarded to the
complaint implementation (row 5) depends on decisions about complaint
requirements (dependence row 5, column 2), about architectural
decisions\footnote{Examples of architectural decisions for the Health Watcher
system are the selected style (layers), patterns, and technologies for each
layer or concern (presentation, distribution, persistence, and so on)}
(dependence row 4, column 4), and about the auditing concern (dependence row 4,
column 6). This last dependency occurs because the team responsible for developing
the \emph{complaint concern} have to know how to develop the extension points for
the \emph{auditing concern}. Moreover, as we can observe in
Figure~\ref{dsm:hw01}, the auditing implementation also depends on the
complaint implementation decisions, since changes in its implementation should
be notified to the auditing implementation team. In this way, there is a
cyclical dependency between complaint implementation and auditing
implementation -- a clear example of non modular design.

\begin{figure}[htb]
\centering
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|l|l|l|} \hline
  &                             & 1     & 2     & 3     & 4     & 5     & 6 \\ \hline
1 & Goals and constraints       &       &       &       &       &       &   \\ \hline
2 & Complaint requirements      & x     &       &       &       &       &   \\ \hline
3 & Auditing requirements       & x     &       &       &       &       &   \\ \hline
4 & Architectural decisions     & x     & x     &       &       &       &   \\ \hline
5 & Complaint implementation    &       & x     &       & x     &       & x \\ \hline
6 & Auditing AO implementation  &       &       & x     &       & x     &   \\  \hline
\end{tabular}
\end{scriptsize}
\caption{DSM Analysis Health Watcher}
\label{dsm:hw01}
\end{figure}


Based on the information hidden principle, we should encapsulate the
dependences between complaint and auditing concerns in a special kind
of interface (a design rule). Design rules establish strict partitions
of knowledge and effort at the outset of a design process.
They are not just guidelines or recommendations: they must be rigorously
obeyed in all phases of design and production~\cite{clark-design-rules-book}.
Applying design rules to our current example, we improve the design structure
by removing the cyclical dependencies between complaint and auditing concerns.
The reviewed DSM is presented in Figure~\ref{dsm:hw02}. Notice that a new parameter
(actually a design rule) was introduced (row 4) and all dependencies are bellow
the main diagonal (there is no more cyclical dependencies).

\begin{figure}[htb]
\centering
\begin{scriptsize}
\begin{tabular}{|l|l|l|l|l|l|l|l|l|} \hline
  &                                 & 1     & 2     & 3     & 4     & 5     & 6 & 7 \\ \hline
1 & Goals and constraints           &       &       &       &       &       &   &   \\ \hline
2 & Complaint requirements          & x     &       &       &       &       &   &   \\ \hline
3 & Auditing requirements           & x     &       &       &       &       &   &   \\ \hline
4 & Architectural decisions         & x     & x     &       &       &       &   &   \\ \hline
5 & Auditing design rule            &       & x     &   x   &       &       &   &   \\ \hline
6 & Complaint implementation        &       & x     &       &   x   & x     &   &   \\ \hline
7 & Auditing AO implementation      &       &       &   x   &       & x     &   &   \\ \hline
\end{tabular}
\end{scriptsize}
\caption{DSM Analysis Health Watcher}
\label{dsm:hw02}
\end{figure}


This idea of defining interfaces between aspect code and adviced code is not
really new. Next, we present some proposals to solve this problem and discuss
how our approach improve existing works.

\subsection{Existing solutions}

% ok, o problema realmente existe. mas ele não é novo. precisamos discutir que
% existem propostas para esse problema. Por outro lado elas não atendem.
% Possivelmente, um caminho é a idéia de que design-rules precisam ser
% rigorosamente seguidas. Sempre tenho dúvidas em relação a essa palavra:
% ``rigorosamente''

\subsubsection{Open Modules}

Open Modules is an approach for dealing with modularity issues in 
AOP~\cite{aldrich-ecoop-05}. Besides exposing data structures and 
functions, Open Modules' interfaces can also expose pointcuts denoting 
internal semantic of events. Clients of these modules are able to advice 
only exported pointcuts. Moreover, by exporting a pointcut, the module's 
developer is compromised to maintain the semantics of that pointcuts, 
which, in fact, mitigates the fragile pointcut problem. 

However, Open Modules do not offers mechanims for describing which 
are the responsabilities of aspect developers. As a consequence, 
module developers are still able to implement part of a concern 
assigned for a different team and they can not assume the existence 
of any behavior expected to be modularized as an aspect. 

For instance, consider the implementation of a mobile
game product line. Listing~\ref{lst:paint-method} presents part of 
a non-variant code responsible for painting graphical elements 
on the screen. Methods \emph{paintBeforeScrolling} and
paintScolling are introduced (by means of intertype declararions),
and represent variation points that should be implemented as aspects for each 
target device. Open Modules does not specify that such methods must be called 
within the \emph{paint} method and that they must be introduced by aspects. Although
not so common, base code calling methods introduced by aspects are presented 
in several examples~\cite{eide-aosd-08}. Therefore, it is necessary to define which 
methods are expected to be introduced by aspects.

\scriptsize
\begin{lstlisting}[frame=single, caption={Dependency of a base code to an aspect code.},label=lst:paint-method, numbers=left, language=Java]
 public void paint(Graphics g) {
	Enemy myEnemy = null;
	int i = 0;
	int j = 0;
	g.setClip(0, 0, Resources.CANVAS_WIDTH, Resources.CANVAS_HEIGHT);
	paintBeforeScrolling(g);
	if (this.scroll.isScrolling) {
	 	paintScrolling(g);
	} else if (!isGameOver){
	 ...
\end{lstlisting}

\normalsize

\subsection{Aspect Box}

\subsubsection{XPIs}

The Crosscut Programming Interfaces (XPIs) is one attempt for defining design rules between aspects and 
advised code~\cite{sullivan-sigsoft-2005,sullivan-ieee-sw-2006}. Such interfaces specify which are the exposed 
join-points of a base code. Although an abstract XPI representation was provided in~\cite{sullivan-sigsoft-2005}, Griswold et. al  
presented how to implement crosscutting interfaces as syntactic constructs of AspectJ~\citet{sullivan-ieee-sw-2006}. 
Based on this approach, design rules are documented using \emph{abstract pointcut descriptions} and constraints 
applied to the base code. These constraints might be written as \emph{declare warning} (or \emph{declare error}) constructs
or just as comments in the source code (when a constraint can not be expressed as a \emph{declare warning} 
or \emph{declare error}). 

XPIs authors argue that an important characteristic of their approach is that it does not require any new construct in 
the AspectJ language and there is no restriction to the pointcut visibility. In fact, this characteristic encourage the use of XPIs in environments that are already using the AspectJ language. However, most of the constraints required for defining the responsibilities of both 
class developers and aspect developers can not be checked using the proposed XPI language. Consequently, it is not possible 
to guarantee, at least automatically, if certain design rules are being obeyed. For instance, we can not express, using AspectJ constructs, 
that a call to a method \emph{must} occurs within the flow of another method. Actually, we can define such a pointcut, but if it does not exist,  no error is reported by the AspectJ compiler. Actually, pointcut constructs in AspectJ were proposed for specifying 
points of execution that should be augmented by advices. They were not proposed for specifying restrictions applied for base code developing. 

Aiming at specifying restrictions in base code using AspectJ like languages, developers are able to check if a {\bf non desirable} pointcut occurs in the source code (by means of \emph{declare error} or {declare warning} constructs). However, there is no construct which can be used for specifying that a specific pointcut {\bf must} occur in the source code. However, in order to improve modularity between crosscutting and base decisions, it is necessary to define what is expected from both teams (not only what aspect developers require, as supported by XPIs).   

Therefore, we propose a new design rule language that can be used for specifying interfaces between aspects and advised code. In what follows, 
we present the syntax and semantics of our proposed language. Then, in Section~\ref{}, we present an evaluation though different case studies. 